import { Injectable } from '@angular/core';


/**
 * This service is used for converting primitive data types and complex
 * data structures like arrays, arrays of objects and objects with
 * nested arrays and objects into URL-safe strings and vice versa.
 * 
 * Previously the service relied on the @jsonurl/jsonurl library
 * (https://github.com/jsonurl/jsonurl-js, v1.1.7), but since it caused
 * server-side rendering to fail for non-default locales, a custom
 * conversion implementation has been adopted. The custom implementation
 * still follows the JSON→URL specification for encoding, and while it
 * doesn’t implement the specification fully, it covers all cases
 * necessary for this application. The JSON→URL specification is available
 * on https://github.com/jsonurl/specification/
 * 
 * The custom implementation below (every function except the public
 * parse() and stringify() functions) has been generated by ChatGPT-4
 * according to the JSON→URL specification, meticulously guided by SK.
 * 
 * To switch back to using the @jsonurl/jsonurl library:
 * 1. Add @jsonurl/jsonurl to package.json.
 * 2. Add `import JsonURL from '@jsonurl/jsonurl';` to the imports of
 *    this service.
 * 3. Uncomment the JsonURL.parse() and JsonURL.stringify() code blocks
 *    in the parse() and stringify() functions below, and modify the
 *    return variables of these functions.
 */
@Injectable({
  providedIn: 'root',
})
export class UrlService {
  constructor() { }

  parse(text: string, impliedArray: boolean = false): any {
    /*
    // Legacy JsonURL method of parsing
    const JsonURLParsed = JsonURL.parse(text, {
      AQF: true,
      ...(impliedArray && { impliedArray: [] })
    });
    */

    return this.fromJsonUrl(text, impliedArray);
  }

  stringify(value: any, impliedArray: boolean = false): string | undefined {
    /*
    // Legacy JsonURL method of stringifying
    const JsonURLStringified = JsonURL.stringify(value, {
      AQF: true,
      ...(impliedArray && { impliedArray: true })
    });
    */

    return this.toJsonUrl(value, impliedArray);
  }

  // Convert a value to a JSON URL string
  private toJsonUrl(value: any, impliedArray: boolean = false): string {
    if (value === null) {
      return 'null'; // Handle null separately
    }
    if (Array.isArray(value)) {
      return impliedArray ? this.encodeArray(value) : `(${this.encodeArray(value)})`; // Encode arrays
    } else if (this.isObject(value)) {
      return this.encodeObject(value); // Encode objects
    } else {
      return this.encodeValue(value); // Encode other primitives
    }
  }

  // Convert a JSON URL string to its proper data type
  private fromJsonUrl(value: string, impliedArray: boolean = false): any {
    if (impliedArray) {
      value = `(${value})`;
    }

    // Handle the representation of an empty string
    if (value === '!e') {
      return '';
    }

    // Decode arrays and objects
    if (value.startsWith('(') && value.endsWith(')')) {
      const content = value.slice(1, -1);

      // Check if the content represents an array
      if (!this.isObjectContent(content)) {
        // Decode as an array
        return this.splitByTopLevelComma(content).map(item => this.fromJsonUrl(item));
      }

      // Decode as an object
      const obj: any = {};
      const pairs = this.splitByTopLevelComma(content);

      for (const pair of pairs) {
        const [key, val] = pair.split(/:(.+)/); // Split at the first colon only
        obj[this.decodeString(key)] = this.fromJsonUrl(val);
      }

      return obj;
    }

    // Decode other values
    return this.decodeString(value);
  }

  private encodeValue(value: boolean | number | string | null): string {
    if (value === null) {
      return 'null';
    }

    if (typeof value === 'string') {
      return this.encodeString(value);
    }

    return encodeURIComponent(value.toString());
  }

  // Encode an array into a string
  private encodeArray(arr: Array<any>): string {
    return arr.map(item => this.toJsonUrl(item)).join(','); // Recursively encode each item
  }

  // Encode an object into a string
  private encodeObject(obj: any): string {
    let encoded = Object.entries(obj).map(([key, value]) => {
      // Encode each key-value pair
      return `${this.encodeValue(key)}:${this.toJsonUrl(value)}`;
    }).join(',');

    return `(${encoded})`; // Wrap the encoded object in parentheses
  }

  private encodeString(value: string): string {
    // Manually encode characters as per specification
    let encodedValue = '';
    for (const char of value) {
      switch (char) {
        case ' ': encodedValue += '+'; break;   // Replace space with plus
        case '!': encodedValue += '!!'; break;  // Escape exclamation mark
        case ':': encodedValue += '!:'; break;  // Escape colon
        case '&': encodedValue += '%26'; break; // Percent-encode ampersand
        case '=': encodedValue += '%3D'; break; // Percent-encode 
        case '+': encodedValue += '%2B'; break; // Percent-encode plus
        case '/': encodedValue += '%2F'; break; // Percent-encode slash
        case '(': encodedValue += '%28'; break; // Percent-encode left parenthesis
        case ')': encodedValue += '%29'; break; // Percent-encode right parenthesis
        default: encodedValue += /^[0-9a-zA-Z\-_.~]$/.test(char) ? char : encodeURIComponent(char);
      }
    }

    // Special handling for strings that are exactly "false", "null", or "true"
    if (['false', 'null', 'true'].includes(encodedValue)) {
      encodedValue = '!' + encodedValue;
    }

    // Escape leading digit or dash
    if (/^[0-9\-]/.test(encodedValue)) {
      encodedValue = '!' + encodedValue;
    }

    // Represent empty string as !e
    if (encodedValue === '') {
      return '!e';
    }

    return encodedValue;
  }

  private decodeString(value: string): any {
    // Handle the representation of an empty string
    if (value === '!e') {
      return ''; // Decode empty string
    }

    // Handle escaped patterns and percent-encoded characters
    let decodedValue = '';
    let i = 0;
    while (i < value.length) {
      if (value[i] === '!') {
        if (value[i + 1] === ':') {
          decodedValue += ':'; // Decode escaped colon
          i += 2; // Skip next character
        } else {
          decodedValue += value[i + 1]; // Unescape character
          i += 2; // Skip next character
        }
      } else if (value[i] === '+') {
        decodedValue += ' '; // Replace plus with space
        i++;
      } else if (value[i] === '%') {
        // Attempt to decode percent-encoded sequences
        let end = i;
        while (end < value.length && value[end] === '%') {
          end += 3; // Move to the end of the percent-encoded sequence
        }
        const percentEncoded = value.substring(i, end);
        try {
          decodedValue += decodeURIComponent(percentEncoded);
          i = end; // Update the index to the end of the percent-encoded sequence
        } catch (e) {
          console.log('Decode string failed for ', value);
          console.error(e);
          // If decoding fails, add the original sequence and continue
          decodedValue += percentEncoded;
          i = end; // Update the index to the end of the percent-encoded sequence
        }
      } else {
        decodedValue += value[i]; // Regular character
        i++;
      }
    }

    // Convert to number if it's a valid numeric string
    const numberValue = Number(decodedValue);
    return isNaN(numberValue) || decodedValue.includes(':') || decodedValue.includes('!') ? decodedValue : numberValue;
  }

  // Check if a value is a plain object (not an array or null)
  private isObject(obj: any): boolean {
    return typeof obj === 'object' && obj !== null && !Array.isArray(obj);
  }

  private isObjectContent(content: string): boolean {
    return content.includes(':') && !content.startsWith('(');
  }

  private splitByTopLevelComma(str: string): string[] {
    const elements = [];
    let bracketCount = 0;
    let start = 0;

    for (let i = 0; i < str.length; i++) {
      const char = str[i];
      if (char === '(') bracketCount++;
      if (char === ')') bracketCount--;
      if (char === ',' && bracketCount === 0) {
        elements.push(str.substring(start, i));
        start = i + 1;
      }
    }

    elements.push(str.substring(start));

    return elements;
  }

}
